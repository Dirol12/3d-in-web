Веб-приложение, использующее аппаратную графику, имеет несколько иную структуру, нежели классическое веб-приложение ввиду его разделение на две уединенные части -- часть,
отвечающую за отображение пользовательского интерфейса в HTML (часть, пресущую всем веб-приложениям), и часть отображения трехмерной графики (рисунок \ref{figure:theory:webgl_app}).
Разрабатываемая система подразделяется на компоненты исходя из их целевого назначения и разные компоненты имеют строго уединенные зависимости.

\begin{figure}[ht]
\centering
  \includegraphics[scale=0.35]{web_with_webgl.png}
  \caption{Отличие приложения для отображения трехмерой графики от классического веб-приложения.}
  \label{figure:theory:webgl_app}
\end{figure}

Типичная модель приложения, производящего CRUD-операции (Create, Read, Update, Delete) обычно содержит в себе набор связанных между собой модулей,
имеющих строго определенные на этапе компиляции связи. Поскольку разрабатываемая система является частным случаем CRUD-системы (без возможности удаления
пользовательского содержимого), то схожая декомпозиция системы может быть применена и для нее. Разрабатываемая система условно подразделяется на следущие модули:

\subsubsection{Компонент отображения}
\label{sub:theory:components:rendering}

Основное назначение компонента отображения -- собственно вызов низкоуровневых API WebGL, итерация по вершинам трехмерной модели и их добавление в контекст
отображения WebGL. Также данный компонент служит для контроля над материалами и шейдерами для отображения различных элементов трехмерной модели.
Данный компонент имеет зависимость от стороннего модуля threejs, который упаковывается вместе с остальными сторонними библиотеками и подключается к
приложению динамически.

Основные части компонента отображения:

\begin{itemize}
\item CanvasRenderer -- модуль, занимающийся непосредственной манипуляцией вершинами трехмерной модели при ее отображении.
\item MaterialPicker -- модуль-описатель свойств материалов, содержит в себе описания всех шейдеров, необходимых для отображения материалов.
\item GeometryIterator -- модуль, предназначенный для итерации по вершинам трехмерной модели для последующего отображения его в CanvasRenderer.
\end{itemize}

Публичный интерфейс компонента состоит из следующих методов:
\begin{itemize}
\item setRenderingModel(modelInfo) -- устанавливает модель для отображения из информации о модели. Аргумент modelInfo -- объект-описатель геометрии отображаемого объекта;
\item render(cameraInfo) -- непосредственно отображает модель на canvas. Аргумент cameraInfo -- трансформ-сущность камеры (ее положение в пространстве и поворот), тип камеры (орто, перспектива);
\item clearScreen() -- очищает экран.
\end{itemize}

\subsubsection{Компонент геометрических вычислений}
\label{sub:theory:components:calculation}

Основное назначение компонента геометрических вычислений -- произведение функциональных манипуляций над точками в трехмерном пространстве, преобразования вершин трехмерной модели, применение
фундаментальных трансформаций к точкам (трансляция, поворот, масштабирование) и реализация вспомогательных математических операций для работы с трехмерной сценой. Данный компонент имеет стороннюю
зависимость от стандартной библиотеки математики JavaScript.Math и от модуля underscore (lodash) для функциональной работы с коллекциями данных и векторами.

Основные части компонента графических вычислений:

\begin{itemize}
\item VectorTranslator -- модуль, реализующий операцию трансляции векторов. Использует библиотеки векторной манипуляции underscore, lodash;
\item VectorRotator -- модуль, реализующий операцию поворота вектора на определенный угол относительно определенной оси. Реализует операции поворота с помощью кватернионов;
\item VectorScaler -- модуль, реализующий операцию масштабирования вектора относительно начала координат или другой произвольной точки;
\item QuaternionHelper -- вспомогательный модуль реализующий арифметические операции над кватернионами и трехмерными векторами. Используется в VectorRotator и является частью публичного интерфейса
данного компонента;
\item VectorHelper -- вспомогательный модуль, реализующий арифметические операции над трехмерными векторами. Используется во всех подсистемах компонента графических вычислений и также является частью 
публичного интерфейса данного компонента;
\item VectorProjector -- модуль-аггрегатор поведения других модулей, реализующих стандартные операции. Реализует преобразования проекций трехмерной модели до отображения ее на экране.
\end{itemize}

Публичный интерфейс компонента состоит из следующих методов и вспомогательных типов:
\begin{itemize}
\item класс VectorHelper -- реализующий армифметику над векторами;
\item класс QuaternionHelper -- реализующий армифметику над кватернионами и векторами;
\item performMVProjection(model, camera) -- реализует проецирование трехмерной модели из пространства сцены в пространство камеры.
\end{itemize}

\subsubsection{Компонент пользовательского интерфейса}
\label{sub:theory:components:ui}

Основное назначение компонента пользовательского интерфейса (Компонента UI) -- реализация возможностей по манипулации состоянием приложения для пользователя, оргазинация
контрольных элементов для вызова функций приложения.
Компонент UI отвечает за управление пользовательским интерфейсом системы и содержит ряд интерфейсов-контрактов и классов для взаимодействия с прочими компонентами
с большой степенью абстракции. Компонент UI предоставляет внешним модулям интерфейс \texttt{IUIDisplayable}, объявляющий метод обязанный реализовать набор правил
по установлению связи между доменной абстракцией системы и объектом, являющимся его моделью отображения.

Компонент UI будучи точной входа в React-приложение (и в приложение в целом), имеет большое число вспомогательных модулей, поэтому перечисление их всех не представляется целесообразным.
Следует также обратить внимание на тот факт, что в терминах Reactjs, модули пользовательского интерфейса также именуются компонентами, что вносит некоторую двусмысленность в перечисление списка
подмодулей компонента UI. Далее в этом списке под компонентом имеются в виду React-компоненты. Фактически, в рамках компонента реализуется модуль на каждый элемент пользовательского 
интерфейса, такой как кнопка или элемент меню. Ниже представлены основные элементы данного компонента:

\begin{itemize}
\item AppComponent -- фактическая точка входа в приложение, является объектом вызова ReactDOM.render и контейнером всех остальных систем.
\item BasicOperationsComponent -- дочерний к AppComponent элемент, является контейнером элементов пользовательского интерфейса, отвечающих за вызов базовых преобразований трехмерной
модели -- трансляции, поворота и масштабирования.
\item MainMenuComponent -- дочерний к AppComponent элемент, реализующий стандартное меню приложения и доступ к глобальным базовым функциям приложения (например, загрузка и выгрузка моделей).
\end{itemize}

Данный компонент является де-факто Main модулем приложения, что означает, что все зависимости на диаграмме компонентов направлены от него. Данный компонент содержит основной тип-точку входа
приложения, выраженную в типе AppComponent. Являясь React-компонентов, AppComponent встраивается в DOM веб-страницы и управляет состоянием отображения всего приложения, выстраивая иерархическую структуру
компонентов.

Тем не менее, компонент UI предоставляет набор публичных интерфейсов для того, чтобы обеспечить соблюдение принципа обращения зависимостей (D -- Dependency Inversion в SOLID).
Данные публичные интерфейсы предназначены для организации сильной типизации и статического анализа связи компонентов и реализации архитектуры приложения в стиле набора плагинов для основного,
так называемого Main-модуля.

Публичный интерфейс, предоставляемый компонентом UI будет иметь следующий вид:
\begin{itemize}
\item event onUpdateGUIState(newState) -- метод-обработчик события, означающий, что необходимо обновление состояния определенного компонента пользовательского
интерфейса. newState -- аргумент-описатель нового события системы, на основании которого произведится обновление.
\item event onNewModel -- метод-обработчик события создания новой модели (другие компоненты системы могут подписываться на обработку этого события).
\item event onModelLoaded(modelInfo) -- обработчик события выбора существующей модели, сохраненной для дальнейшего использования в локальном хранилище приложения, modelInfo --
метаинформация о выбранной на пользовательском интерфейсе модели.
\end{itemize}


\subsubsection{Компонент обработки геометрии}
\label{sub:theory:components:geometry}

Основное назначение компонента обработки геометрии - работа со структурами данных, описывающими трехмерные модели, реализация логики по манипуляции трехмерной геометрией,
основных операций при редактрировании моделей -- подразделения и выталкивания, методы оптимизации моделей -- удаление лишних вершин и треугольников.
Данный компонент реализует ключевые абстракции системы, такие как ModelGeometryInfo -- описатель геометрии трехмерной модели, аггрегирующий в себе информацию о положении вершин модели
в модельном пространстве, а так же информацию о соединении вершин в треугольники. CameraInfo -- описатель положения и поворота камеры и другие важные абстрации.

Основные модули компонента обработки геометрии:
\begin{itemize}
\item класс ModelGeometryInfo -- хранилище двух списков Vector[] vertices и number[] triangles. Описывает геометрию трехмерного объекта и содержит координаты каждой из вершин модели в
модельном пространстве а также группы по три индекса вершин, составляющих единый треугольник.
\item класс ModelLoopExtruder -- тип, реализующий стратегию выталкивания определенных вершин модели поперек замкнутой цепочки вершин -- одну из стандартных операций редактора трехмерных моделей.
\item класс ModelGeometrySubdivider -- тип, реализующий стратегию подразделения модели для увеличения числа треугольников и увеличения ее детализации -- одну из стандартных операци создания
трехмерной модели из примитива.
\item класс VertexGeometryHelper -- тип-утилита, реализующая функционал для работы с полигонами и вершинами модели, позволяя найти полигоны, соседствующие с полигоном или вершины, соседствующие
с вершиной. Данный тип используется всеми другими типами данного компонента, однако предоставляется в общий доступ для сторонних использований.
\end{itemize}

Публичный интерфейс данного компонента представляет из себя набор методов для манипуляции структурами данных:
\begin{itemize}
\item getExtruderFor(modelInfo) -- предоставляет реализацию типа ModelLoop-Extruder, сконфигурированную для данной модели. Является методом фабрикой, предназначенной для использования в других
частях системы (например, в компоненте пользовательского интерфейса, внутри обработчика событий по манипуляции моделью).
\item getSubdividerFor(modelInfo) -- предоставляет реализацию типа ModelGe-ometrySubdivider, сконфигурированную для данной модели. Является методом фабрикой, предназначенной для использования в других
частях системы (например, в компоненте пользовательского интерфейса, внутри обработчика событий по манипуляции моделью).
\item getSubdividerFor(modelInfo) -- предоставляет реализацию типа VertexGe-ometryHelper, сконфигурированную для данной модели. Является методом фабрикой, предназначенной для использования в других
частях системы (например, в компоненте пользовательского интерфейса, внутри обработчика событий по манипуляции моделью).
\end{itemize}


\subsubsection{Компонент хранения}
\label{sub:theory:components:persistance}

Основное назначение компонента хранения данных состоит в сохранении состояния сессии использования приложения между перезапусками, хранении пользовательских настроек без необходимости доступа к
удаленному серверу, кешировании данных о трехмерных моделях в их бинарном виде при выгрузке модели из области работы и для реализации оффлайн-доступа к системе.
Поскольку в первой версии разрабатываемой системы не подразумевается возможности кросс-клиентского сохранения данных, что означает что при смене клиента (компьютера или иного устройства доступа),
контекст выполнения приложения не будет сохранен, основным механизмом длительного хранения данных в приложении выступает механизм браузера Local Storage.

Однако для сохранения возможностей по расширяемости приложения следует ввести дополнительный слой абстракции (в виде абстрактного класса либо интерфейса). Это позволит дореализовать более
централизованный механизм синхронизации в дальнейшем и соблюсти принцип Открытости-Закрытости (O-pen-Closed или O в SOLID). Принцип Открытости-Закрытости заключается в такой реализации
компонентов системы, чтобы реализация дополнительного функционала производилась без модификации самих компонентов, а путем внедрения новых компонентов и изменения конфигурации системы для того чтобы
этот функционал задействовать. В случае с компонентом хранилища, реализован абстрактный слой доступа к данным -- асинхронный интерфейс IMo-delDataRepository

 \begin{lstlisting}[language=TypeScript, label=lst:domain:html]
    /// #!/usr/env/node
    /// Target=ES2016

    const Promise = import 'promise'

    default export interaface IModelDataRepository
    {
        /// Async data retrieval operation.
        public async getModelData(modelId: string): Promise<ModelGeometryInfo>;

        /// Async data storage operation.
        public async storeModelData(geometry: ModelGeometryInfo, modelId: strning): Promise<void>;

        /// Async data retrieval operation. Lists all the items in the storage.
        public async listAllModelData(): Promise<ModelGeometryInfo[]>;

        /// Updates the 'last modified' date on the model info storage item.
        public async touchModelData(modelId: strning): Promise<void>;
    }
\end{lstlisting}

Поскольку данный интерфейс является полностью асинхронным (резульатами выполнения всех операций выступает Promise-объект), не составляет труда реализация данного интерфейса, работающая, например, с
сетевым (потому асинхронным) транспортным уровнем, либо чтение из синхронных источников, например из cookie-объектов или localStorage. 

Основные модули компонента хранения:
\begin{itemize}
\item Базовый интерфейс IRepository, являющийся родительским для всех интерфейсов-репозиториев
\item Интерфейс IModelDataRepository
\item Класс LocalStorageModelDataRepository, реализующий интерфейс IMo-delDataRepository. Является асинхронной реализацией, построенной на основе синхронного доступа к Browser Local Storage.
\item Интерфейс IUserSettingsDataRepository
\item Класс LocalStorageUserSettingsDataRepository, реализующий интерфейс IUserSettingsDataRepository. Реализует асинхронный доступ к пользовательским настройскам (предпочитаемый размер окна,
горячие клавиши и т.д.)
\item Интерфейс ICompiledShaderCache
\item Класс LocalStorageCompiledShaderCache, реализующий операции доступа к прекомпилированным шейдерам для различных материалов в трехмерной модели.
\item Интерфейс IConfigurationProvider, реализующий чтение конфигурации приложения, необходимой для работы метода-фабрики (опционального инстанциирования репозиториев).
\end{itemize}

Публичный интерфейс данного компонента представляет из себя набор интерфейсов и методов-фабрик, реализующих инстанциирование экземпляров классов, реализующих данные интерфейсы:
\begin{itemize}
\item Интерфейс IRepository
\item Интерфейс IModelDataRepository
\item Интерфейс IUserSettingsDataRepository
\item Интерфейс ICompiledShaderCache
\item метод-фабрика getInstanceFor<T>(), где T является дочерним к интерфейсу маркеру IRepository
\end{itemize}